### protobuf ：https://www.yuque.com/docs/share/838ab0ba-5347-4829-803e-9a218a19bffd?#

应用层协议设计：  进程之间~ （包括客户端服务端）
	如：客户登录，登录服务器与数据库
		不同业务
		
设计一个通信协议：
	1：考虑跨平台， 如客户端 webjs , android java, windows c/C++
	2：大小端
	3：协议数据大小  二进制标记小，文本比较大
	4：有时候需要可读性，文本的可读性好
	5：安全的问题，比如流行的https
	6：数据压缩
	7：怎么判断他是一帧完整的数据（完整的包）
	8：解析效率
	9：协议可升级问题，升级后兼容性问题
  
  问题：
	粘包分包   客户端发三个包，服务器能收到几个？
	反射是什么？
	webrtc的项目 ===>文本的方式可读性高，方便调试
    相关序列化协议性能对比：说protobuf是json性能的十倍
    存储的协议？

	序列化/反序列化 ---》比较成熟的开源的序列化方案， json xml protobuf 跨平台跨语言
	判断包的完整性 ---》
	协议升级      ---》
	协议安全      ---》
	数据压缩      ---》

	对象的序列化 ==》把对象转换为字节序列、或者文本的过程
	反序列化  ===》恢复为对象的过程
	序列化的方式有很多
	redis的通信协议

	序列化的方法：
		TLV编码及其变体 (Tag length value)（protobuf）
		文本流编码： xml/json
		固定结构编码： 主要是头部固定，可扩展头部
		    TCP(头部字段已经固定好) seqno  自定义协议一般也是  
		内存dump： 一般嵌入式用，网络不用，最早51单片机用
			struct结构体的方式，结构里面嵌套结构无法实现


	如何判断包的完整性？
		1.以固定大小字节数。
		2.以特定符号来分界（如特定的结尾\r\n）。
		3.固定包头+包体结构 (使用最多)
			==》header+body
		4.在序列化后的buffer前面增加一个字符流的头部，其中有个字段存储包总长度，根据特殊字符（比如根据\n 或者\0）判断头部的完整性。
		     这样通常比3要麻烦一些，HTTP和REDIS采用的是这种方式。
		     收包的时候，先判断已收到的数据中是否包含结束符，收到结束符后解析包头，解出这个包完整长度，按此长度接收包体。

序列化：按照一定的规则，把内容做处理，以二进制或者文本形式存储。 
	json,xml,protobuf相当于规则
反序列化：按照相应的规则，把内容重新还原出。

协议设计范例参考：
	STAG  协议数据包的开始标志     例如：h264 0001
	version  版本号 --》也是有必要的，版本迭代
	checksum 校验和 --》计算稍微耗时，非必须
	type     类型，body的数据用不通的格式  0--json 1protobuf。。。
	seqno    通信数据报文序列号（判断发送成功用）服务器应答用
		确定有没有丢包，比如确定qq消息重发
	length   报文内容长度（根据需求设置长度）
	reserve   预留字节，消息心跳灯
	body

即时通信协议设计
适合tcp传输用
	length    4     整个包的长度 协议头+body
	version   2     协议版本
	appid     2     识别不同的用户 第三方库使用时id+密匙识别
	serveice_id  2  不通分组   login组
	command_id 	 2  分组里的子命令 登录 退出 踢人
	seq_num		 2  包序号
	reserve      2   保留字节
  
md5 一般大文件校验 比如下载文件

分包 粘包问题
	粘包   包1：50字节  包2：50字节   ==》直接收到 100字节（在环形buffer或者队列里）
			从头取，先预读4字节，需要50字符，解析出一个包。。。
	分包   100字节的包   ==》收到  50字节包+50字节包 （放在buffer中）
			先预读4字节， 需要100字节   --》不够那就等等接收

tcp相关：分包，粘包，拥塞控制

常用的协议：http协议

REDIS协议：
基本原理是：先发送一个字符串表示参数个数，然后再逐个发送参数，每个参数
发送的时候，先发送一个字符串表示参数的数据长度，再发送参数的内容。

协议升级 ：增加字段  大版本
	如果头部可扩展，需要在头部加一个字段  extended length （扩展长度对头做扩充）
1.通过版本号指明协议版本，即是通过版本号辨别不同类型的协议
2. 支持协议头部可扩展，即是在设计协议头部的时候有一个字段用
来指明头部的长度。

协议安全：
	有代码 xxtea 固定key   ===》新老师  做游戏用的加密
	      AES    固定key   ===》加密的时候长度要固定  16的倍数
   1. xxtea 固定key
2. AES 固定key
3. openssl
4. Signal protocol 端到端的通讯加密协议

数据压缩：
	1：deflate
	2：gzip
	3：lzw
	数据过少 protobuf没必要做压缩，文本可以考虑压缩，带宽ok的话可以不考虑


prtobuf:比较快  二进制协议一般比较快
.proto 文件

syntax   proto版本，默认版本2
package    对应C++命名空间

import     引用其他的proto文件

repeated  关键字，重复，类似数组，可以嵌套对象
create.sh 指定源文件和输出文件的位置

根据proto文件生成.h和.cc文件

用生成的对象去做序列化和反序列化   ---》提供了相关的方法
protobuf做序列化后是二进制的
im代码分析:
	其中 不通的commondid用不同的反序列化方式

3.1 protobuf的编译安装
3.2 protobuf的使用流程
3.3 protobuf的编码原理
3.4 protobuf升级问题     
        
