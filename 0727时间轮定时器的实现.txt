云盘项目的实现：
	1：安装fastdfs及测试；
	2：安装mysql及测试，以及相关密码
	3：安装redis及测试
	4：安装nginx及fcgi及测试相关
	延伸：使用集群的方式对存储进行扩展，协程，集群，epoll，线程池
使用web的进行测试：
使用客户端进行测试： 电脑app，Android环境等

进行代码的实现了：
	
刷题，掌握一些代码实现；


在线的c++ 手册：
https://zh.cppreference.com/mwiki/index.php?title=Special%3A%E6%90%9C%E7%B4%A2&search=thread



深入理解nginx：
	https://github.com/russelltao/geektime-nginx
	http://tengine.taobao.org/book/
nginx handler模块以及各个模块的学习
	https://www.cnblogs.com/wych/p/4094815.html
	
	http://redisdoc.com/
skynet，一个好的网络库（lua与c的交互）：https://github.com/cloudwu/skynet



定时器的实现：
	1：二叉树最小堆的实现 ：   经典的是boost中的asio
		四叉树  golong
	2：红黑树  有序和存储     nginx的定时器   openresty共享内存 shared_dict
		epoll 也是 通过红黑树组织结构
	3：C++实现方案中，定时器存的哪些东东？  过期时间戳+callback
	4：时间轮： ==》粒度小  可预测
		对于多个超时事件，我们只需要关注要发生的事，关注最近的事
		应用：不一定要实现定时器，可以自己加个时间戳， 需要使用个不一定精准的
			  游戏中的buff，可以用时间轮
			  
	
		案例：连接10s没有收到数据（心跳包），服务端就断开连接
			方案一：
				conn记录上次收到的数据包的时间
				map<int conn*> 定时器来检测，连接是否发送数据
				now -tiwk来检测
				这种方案在连接过万的时候很耗时
			方案二： ==》存储的是过期的事件
				生成10个桶子 马上过期  1s后过期 。。。9s后过期
				更新桶子，收到一个心跳包，放在第十个桶子
					如果5s发送一个数据包，10s超时，会重复 ===》加引用计数 ，桶子里存的是对象
						重复的以最后一个桶子为标准过期
					取第一个桶子，将桶子里面的连接踢掉， 引用计数=0，踢掉
					并将第一个桶子清空放到队尾
				删除桶子 ===》引入引用计数
				
				客户端主动断开连接？  直接给引用计数置0就好
				
				
				心跳包，超时断开？
	5：高并发场景下，时间轮的设计：  linux中定时器crontab定时器也是用时间轮实现的
		1：多线程
		2：
		
		skynet的定时器：时间轮实现高并发   与核数匹配的工作线程生产，发往一个定时器线程（通过时间轮处理轮询处理）
			1：定时器的时间精度默认是10ms
			2：只解决2^32 最大过期时间42.9亿*10ms
		问题：	3：底层不提供删除操作    为什么？
				为什么时间坤适用于高并发操作？
				
				
			skynet时间轮里用了数组来实现   ==》O{1} 数组访问时间片
					第二层应用了 ：循环数组和链表
	6：时间轮与 红黑树  堆比较
		1：数组下标，  直接获取过期列表
		2：时间轮存储的是间隔    而不是时间戳
    
    时间轮缺点：
			数据是一直在移动的
    
    
    了解skynet定时器的源码实现！
