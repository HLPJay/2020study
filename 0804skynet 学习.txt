skynet是一个轻量级的后台服务端框架，设计目标是为了游戏。  但是其他行业，如金融也用
	actor模型是怎么衍生出来的？ 
	1：多核开发？   
		多进程  隔离性（运行环境）好，统一性（数据同步）比较差
			socket（通用）  共享内存  管道  信号量  unix域
			解决方案：（开源公共组件）
				消息队列（ZeroMq ==》库：socket封装）  
					==》最终一致性问题（强调通知）  
					==》zeromq 推拉模型（负载均衡），请求回应（redis，tcp） 监听发布模型， 
					==》协议问题，断线重连，进程启动顺序问题，负载均衡问题（一致性哈希）
				rpc（grpc）   
					==》强一致性问题 （银行转账问题）（强调处理结果）
				zookeeper  （数据模型+监听机制） ==》了解zoomkeeper数据模型
					哨兵，集群等
					==》解决服务协调的问题
						1：配置管理问题==》交给zk管理
						2：集群管理  redis的哨兵模式 （两个连接，一个发送命令，一个检查master可用） 解决高可用问题
							奇数个哨兵   ==》 利于投票
						3：统一命名问题（相同功能的服务统一命名）
						4：状态同步问题
						5：分布式锁的问题 （多线程环境保证临界资源同时只有一个线程获取锁） 完备解决分布式锁问题，集群模式+监听机制
					竞争资源的进程： ==》了解分布式锁， 释放锁有问题会引发问题思考~
						1：向数据中心请求锁（redis可以作为数据中心）
							redis中  setnx()实现分布式锁+过期时间（与执行逻辑时间相关）或者其他额外线程释放锁
							setnx(key, 唯一标识， timeout)
						2：获取锁
						3：执行逻辑
						4：释放锁
					监听机制：
						1：观察我们节点数据变化
						2：观察节点子节点的变化
						3：观察节点的创建
						4：观察节点的删除
		多线程  隔离性差  需要用锁来进行控制 统一性强 
			==》消息队列 pipe  锁 
			actor 并发模型 
			
			reactor  proactor  ==》网络模型
			actor csp  ==》并发模型
		协程
		
		
		并发： 同时运行 
		并发模型： ==》平衡 隔离性  统一性
			1：actor模型   erlang语言（进程），skynet用框架解决actor actor未并发实体
				从语言层面抽象出进程的概念 ==》隔离性强，统一性差  支持并发
					==》用于并行计算
					==》actor是最基本的计算单元
					==》基于消息计算    （每个actor都有mailbox，通过消息通信）
					==》actor互相隔离 通过消息来进行沟通
			2：csp         go语言作为代表 goroutine作为并发实体
	2：skynet中的actor
		skynet_context actor的组成
			==>隔离的环境（内存块+lua虚拟机），回调函数（消费消息），消息队列（mailbox存储消息）
		
		skynet中actor叫服务   c语言+lua
		1：c actor服务 ==》   C语言 日志服务
			隔离环境就是申请一块内存 回调函数取消息并执行
			hook  jemalloc中分配内存的函数
			__init  __create  __release  回调函数
		2：lua服务
			lua虚拟机 隔离环境 
		actor是通过回调函数运行的，如何调度呢？   
			多个worker线程执行
				==》全局消息队列（有消息的actor消息队列指针） 
					==》每个actor消息队列（存储专属actor的消息队列） 
		多个worker线程：	
			1：取出actor消息队列
			2：取出消息
			3：通过回调函数(参数是消息)执行actor
		消息的生产和消费：
			生产：	
				1：actor之间
				2：网络中的
				3：定时器
			消费： 回调函数
		skynet相关锁：   互斥锁和自选锁的区别？
			1：互斥锁
			2：自旋锁
			3：读写锁 
				读状态加锁（共享锁 其他线程以读的模式进入临界区，不会阻塞）  
				写状态加锁 （独享锁 其他线程尝试访问该临界区都会阻塞）
				读远大于写的情况下使用
			4：条件变量 ==》虚假唤醒问题
		skynet中的线程：
			1：timer
			2：socket
			3：worker
			4：monitor ==》检测消息过载服务
	skynet_server.c		
		weight 给工作线程加权重， 0 1 2   取出全部。一半，1/4消息进行处理
		取消息并回调调用的时候  加的自旋锁 ==》不用线程切换
		没有消息的时候， 条件变量 休眠
		
	了解：什么时候唤醒？
	思考：为什么actor之间发送的消息，不需要唤醒worker线程，条件变量
		worker取消息，执行消息(actor之间发送消息)  至少有一个worker在执行中
