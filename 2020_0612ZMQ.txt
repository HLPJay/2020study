mq消息队列  Message Queue，先入先出，存消息
1：MQ消息队列    主要用于限流，服务削峰==》什么意思？
2：什么时候用消息队列？
	1: 不同的服务
	2：不同的线程
	3：不同的进程
3：消息队列只能用于高并发上吗？  不是的
4：流水线上的传送带~   ==》类似消息队列
   线程池
           普通的队列，任务取出就没了 
   ipc 进程间通信~
5：发布订阅模式 ===》订阅的人应该每个人都能收到消息（广播）
	kafka   ZeroMQ

   生产者消费者模型 ===》取出来就没了 （多个生产者多个消费者）

   REQ -------- REP 请求响应模型 
       --------
6：消息可靠性处理===》参考TCP，redis怎么保存缓存的
		1：确认ACK，如果没有收到ack，超时重传
		2：定义序列号，消息序列号是连续的，不连续，是丢了消息。（生产者消费者模型不适用）
		3：备份
		4：持久化 RocketMQ支持，也支持事务，zeromq要自己实现
7：消息吞吐量：每秒发送的消息数 （研究mq的特性）
与哪些因素有关，怎么计算的？
		1：REQ-ACK模式，能否做到高吞吐量（保证消息不会丢）
		|    (1)send===>       |
		|   <===act(2)         |
		|     (3)send==>       |
		|     <=====act(2)     |
		client                server
		优点：低时延，确保消息可达
		2：多次send，依次ack模式，能提高吞吐量
		3：响应速度：毫秒级别，微妙级别
			批量消息传输（类似tcp粘包）

			批量-响应速度 批量多，响应速度下降
思考上述问题，使用mq。
8：秒杀活动，最关键的问题？
	（1):最怕5个商品被10个人购买的问题
	（2):用户体验，响应速度 ===》参考教程图片

	锁定商品库存，确定多个用户中哪个可以拿到。
		后面多个服务，可以拆开做，通过消息队列发布订阅模式（返回订单信息，短信通知，统计数据可以并行）
                         订阅
即时通信消息   --》消息队列---》 大数据分析系统 
                        ---》存储聊天消息

问题：
           观察者模式用在同一个组件的多，  观察者模式是什么？？？
           IPC是什么？

9：消息队列==》流量控制(削峰)
隔离网管和后端服务，达到流量控制和保护后端服务的目的。
	减轻后端负载：生产者生产消息队列很多，但是消费取数据很少
	削峰：限流，消息队列到一定的阶段，网关直接返回给app。==》业务繁忙，请稍后。。。（12306）==》经常触发，触发报警，扩展后端处理能力

	网关做负载均衡：过滤ip，过滤请求。。。（没有削峰的能力）
	扩容的问题：类似线程池
		网管把要处理的内容，扔到消息队列（服务）里
		要扩充的时候 ---》通过其他服务1，服务2，服务3 等去取数据，可以增加服务取数据。

	网关后面加消息队列（独立的服务），方便水平扩展，多个服务或者线程取消息队列。
  
  10：通过消息队列实现解耦。
	消息分发与消息处理分开。
	早期的系统，B,c,d要调用a的接口，需要a提供接口，耦合度高==>通过接口主动推送

	用消息队列实现了解耦，消息队列有标准api，b,c,d订阅消息队列，新增直接加（订阅就好）。 
	TCP网络相关通信，IPC进程间通信，

	zeromq要先订阅（主动连接消息队列），然后在发布Pub

	关注zmq的接口！！！订阅--发布。。。
11：基础概念
	broker 是Mq的服务器，有服务来了
	生产者消费者
	点对点消息队列模型  ===》rabbitmq 点对点 （可以通过路由实现发布订阅的模式）（交换机模型）
	发布订阅消息模型==》每个人取不影响别人
	消息的顺序性保证
	消息的ack确认机制==》
	消息的持久化 ===》

rocketmq
	----------》                               -----》
				入口 ------ 持久化------- 出口            处理完业务，数据再去应答
	《-----ack-----                            《----ack---  （防止后台业务出问题，消息队列已经删了）
		队列收到可以做应答，要确保消息不丢，存到硬盘中再回应

	消息队列的同步和异步（不用等消息确认）收发
		1》为什么采用发消息异步的方式？ 和tcp ack一样
			发一次，应答一次，==》吞吐量很低 ==》批量持久化，批量应答
			比如，数据要持久化，肯定是批量刷硬盘
	消息的事务支持==》redis，mysql类似，事务回滚
12：常见的消息队列产品==》响应和吞吐量相反
	RabbitMq    RocketMq   kafka   ZeroMq
  
  批量消息传送 --》吞吐量上去，时效性降低
13：ZeroMq根据自己的业务需求，分析吞吐量和时效性
		  不是独立的服务，嵌入到自己的业务中。
		  没有中间商，降低时延。
		  比较灵活，不支持持久化。
		  可以用在嵌入式中
		kafka，中间是个服务。
14：TCP 一对多 reactor模式 ？？？
15：zeromq优化了我们不用关注的点有哪些？ 和传统的socket比较
16:测试代码
	整理编译安装的流程 ，注意安装一些必要的库。
	一般不要用git上的master版本，会有问题，用稳定版本
	zeroMq主要是长连接。
	中文的指南是过期的  要注意，最好中英文对照着看
	参考书籍：《ZeroMQ 云时代极速消息通信库 .pdf》

	测试服务器端，客户端启动的先后
//代码流程 
zeroMq没有独立的服务，要嵌入到自己的程序中去调用api
REQ/REP 请求响应模型 一请求一响应，收不到响应是发不出去的
测试：加两个send 一个recv
	创建客户端，绑定类型，连接服务器，请求，应答
	创建服务器，服务器是要绑定的，接收，应答
PUB/SUB模型 发布订阅模式 ==》可以做过滤 字符匹配
	会丢消息，先启动发布端的情况下。
	创建socket指明类型，发布温度
PUSH/PULL模型  推拉模型 ，可以做并行处理
	把任务分发到不同work，然后汇总
	pull谁抢到是谁的(类似生产者消费者)
	测试代码，三块
	整理模型与代码的对应
	加结束符"\0"做封装 有两个push==》去理解
	开多个work测试==》理解代码，并行计算
	push的接口内部有均衡算法，多个worker自己分发，send时用户层不用关注有多少pull
ROUTER/DEALER 
	客户端可以多个处理 
	broker实际是中间的一个服务
	可以多个worker    是均分的==》中间转发
	请求应答模式，提供了多个后端服务器
  
  要去通过文档整理相关的api
编译的时候要加-lzmq

kafka大数据用的比较多
