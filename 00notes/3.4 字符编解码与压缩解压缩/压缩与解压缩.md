# 压缩和解压缩
## DEFLATE ==>无损数据压缩算法

	使用了LZ77算法和哈夫曼算法，压缩和解压缩源代码可以在zlib找到。

## 压缩和解压缩原理
	压缩：找到重复出现越多的字符串，用越短的字符取去代替。(均匀分布的字符，往往无法压缩)
	压缩有极限：==》香农极限
## 相关算法
###	1. Deflate压缩算法 ==》压缩数据流的算法。 （zip,7z, xz等都用到）
	三种压缩模型：
		1：不压缩数据
		2：压缩，先用 LZ77，然后用 huffman 编码。 算法默认的压缩树
		3：先用 LZ77，然后用 huffman 编码。 （压缩器自生成的压缩树） 
		   ==》最合理数据被分成不同的块去做压缩处理的，不是一次性全部的。

###	2. LZ77算法： ==》比较耗时
	理解关键字：短语字典，滑动窗口（可以自己设计大小），向前缓冲区。
	压缩实现：移动滑动窗口，寻找能与滑动窗口中匹配的最大短语，然后，标记出来，没有找到则直接输入。
	解压实现：把标记，转成字符，重新塞入滑动窗口中。

###3. 哈夫曼算法:贪心算法构建最优前缀码
（前缀码是为了解压用），会根据出现的频率，自底向上构建哈夫曼树。
根据频率表：

|字符|a| b| c| d| e| f|
|-----|----|----|----|----|----|---|
|出现频率 |45 |13 |12 |16 |9 |5|

生成哈夫曼树，然后根据生成的树取编码。

	压缩：按顺序存入哈夫曼对应的码表。
	解压：利用配置文件重构哈夫曼树解码。

## 实际使用
### 了解一下：
	deflate采用的改进版LZ77算法：3字节以上重复才编码（小于3反而会更长）<br/>
	deflate无损压缩解压算法：先用LZ77压缩，再用哈夫曼编码（编码表huffmantree和编码后的data都一起放置在文件中）<br/>
	deflate解压算法：通过二进制文件构建huffmantree，生成符合LZ77的字符，再LZ77解码。<br/>

### 扩展：
**deflate(RFC1951):** 一种压缩算法，使用 LZ77 和哈弗曼进行编码；<br/>
**zlib(RFC1950)**:    一种格式，是对 deflate 进行了简单的封装，他也是一个实现库(delphi中有 zlib,zlibex)<br/>
**gzip(RFC1952)**:    一种格式，也是对 deflate 进行的封装。<br/>

gzip = gzip 头 + deflate 编码的实际内容 + gzip 尾<br/>
zlib = zlib 头 + deflate 编码的实际内容 + zlib 尾<br/>

### gzip的格式分析（头部+数据+尾部）


### zlib的源码分析


### 其他：
    nginx用到了gzip，nginx中是可以开启gzip是否压缩。<br/>
    视频压缩一般用到有损压缩，图片有损压缩导致图片模糊<br/>
    LZ77 会分段   比如32k<br/>
	哈夫曼编码  也会分段编码  比如也用32K<br/>
	用zlib  deflate压缩   压缩成.gz文件<br/>
	流媒体编码  多h264 AAC h265 MP3编解码<br/>